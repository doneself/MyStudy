# 编程到底难在哪里

## 01
我写写非计算机专业人员，容易卡住的角度吧。


不需要懂算法，也可以学编程。这是两门不同的课。
代码慢不要紧，只要能运行，能替你省时间就行了。
就像英语不需要好到去同传当翻译，能帮助你更好生活，就不错了。
未来你喜欢，可以继续提升，或者引用大牛代码来提升速度。
比如系统自带sorted()，不懂排序各种效率对比，也能解决问题。

我仔细想了一下，学Python初级被卡住的同学。

学习目标是简单Python，不求速度，没有算法考虑，只要结果对就行，学习难度低。
基本就是答案补充里说的，用自然语言写完就行了。
而且Python语法规则又相对简单好学。

一部分人只看书不做题。书的确看懂了，最后还是不会写。
代码有些格式和习惯，得练习很多次。这种不废话多讲了。基本跟学正确书写差不多，一定量的初级练习必须的。
这部分不多讲，小学老师已经讲过无数遍了。

还有一部分初中数学部分不行…… 无法把问题拆分成合理步骤，然后解决。
逻辑、集合、循环、加减等等，虽然都是初中知识，并不所有人都学好了……
曾有前辈讲，虽然很多人从没学过编程，但他们实际就是编程思维。他举例，某人重新安排部门业务，把几十个人的工作内容调整，让效率大幅度上升。
发现生活中问题，定义问题，拆分问题，用手上可用资源解决，这个思路就是逻辑的。



最后还有一部分脾气太急…… 所以学不好编程。
一旦做题卡住，连10分钟痛苦思考时间都不愿意浪费，马上网搜答案。
但网络很多答案，直接用高级功能解决低级问题。复制那行代码，并没提升自己解决问题能力。
比如大部分Python书籍，每章节都安排了习题。
一般规则是，目前学到哪，用目前知识点来解决问题。
比如某初级习题，需要把字典dict，按照值value排序后输出。
搜“ Python 字典 value 排序” 马上就有一句话答案对不对？
a = sorted(my_dict.items(), key=lambda a: a[1])
但如果用目前学的知识，转化list后排序，或循环找出每次value最小值然后删除等，你就的确在学Python了。
就像小学题，就用小学知识解，这样学比较稳，不要上来就找高级答案解。



最最后还有买错了教材，或者选错运行环境。
有些教材有错误或者过时了，有些教材晦涩难懂。这些还好，你网络搜索、专业论坛、国外公开课、国外教材，一般组合下来，能解决大部分问题。
其实不少国外经典教材，版权CC，且被热心国人翻译成中文版，网络都能搜到。
一般最好几本书，多个视频搭配，会比较全面。跟参考书+教科书搭配，差不多概念。
运行环境，Mac + Pycharm 新人基本没啥大烦恼。
如果环境太不行，新人又不太看得懂各种出错提示，新手期会很痛苦。
好玩，才会让你有动力一直学下去。学习不该是痛苦的事。



大概这些。
我赞同编程普及的重要性。希望大家都能试一试。
再慢的代码，也是代码。
尤其不着急时提前学，就像小朋友看古诗，自然不赶时间，一切慢慢来。
需要时候，很自然拿出来用。这个过程就痛快了，跟养猫养狗养植物一样，只是个过程，一种体验。
试一试吧。

想了想，再补充，用国外经典教材（不少有中文版）、公开课（不少有中文字幕）、认真多做基础习题（不要上网找答案）能解决大部分问题。
不需要钱，不用报班。
只要有耐心和时间，真的只是个过程。
如果英文好，过程会更顺畅。搜过不少中文博客里错误笔记，很误导。
直接读英文官方网站，看英文论坛，能少弯路。



最后再补充一个，如果你能读到这里，应该是个用功的好孩子。
不要太用功！
很多模块、关键词等，给特定情况设计的，普通代码，普通数据根本用不上。
能不学的都不学。把特别基础的string, list, dict... 那些学特别牢固。
选经典教材一般可以避免，书上提到的章节内容好好学，就够用了。不必读非得读到高级编程，或面向工程师的书籍。
也没必要买厚厚Python库大全之类，有官方文档，直接查很快。
人生苦短，学最有用的部分，够用就行。
就像认字从高频词学，5000个字生存交流，基本旅行够用，这个难度低。
就像初中数学在生活中很重要，但没必要人人都去大学读数学专业。

未来你觉得游戏好玩、或者大数据分析好玩，根据项目，再一点点补全都行。
兴趣第一，实用至上。



最最最后再补充：

学学代码，用来解决自己个人问题，这过程挺有趣。
不要被计算机专业同学的抱怨吓住了。他们要给大量用户写，难度的确更高。
你给自己写代码，难度远远低于给用户写代码。

比如输入数字，你肯定输入正确数字，而用户可能输入“一”，“one”，或者字母，空格，表情符等各种东西。
你读本地文件，这文件肯定存在，而用户文件可能不存在、或者空文件、奇怪格式等等。

给用户写代码，就必须充分考虑各种异常，各种不同环境，不同操作等等。
要尽量保证即使有异常，也能执行程序。
他们还要考虑前人遗留代码，文档要求，与其他语言、模块合作等等等。
他们还要与别人的bug做大量斗争。

你只写给自己用，难度没有那么高，很多东西可以跳过不用学。
不会的可以搜解决方案，可以网络搜代码修改使用。
就像不会做鱼，临时上网搜：“怎样做烤鱼”，按照步骤略修改使用。
专业厨师不会这样，但普通家庭主妇参考网络菜谱做菜，是很常见的行为。
学好基础后，就能看懂其他人代码，修改成合适自己解决方案。

不要陷入学习的汪洋大海里，学以致用。

大概这些，加油！
## 02
他在1986年的一次茶话会上发了一篇受邀论文（论文的开头就是“谢邀”），题目就是《没有银弹－软件工程中的根本和次要问题》。 这个人就是IBM大型机之父，Frederick Brooks. 整个论文不太长，有兴趣的同学可以找来读读。在他的经典书《人月神话》中也有收录。 在30多年后的今天，我们在知乎上讨论这个问题，他却早就回答了。他的答案，至今看来，都没有一丝一毫需要修改的地方，毫无瑕疵。

布鲁克斯把软件开发中的困难分为两类： essence，可以译为本质困难或者主要问题，指的是软件开发中不可规避的问题，就是软件本身在概念建构上存先天的困难，也就是如何从问题领域，发展出具体的解决方案。 Accident，可以译为次要因素或次要问题，指的是把解决方案实施到电脑上，所遇到的困难。

他认为软件开发中无法规避的四个特性是： 复杂度； 一致性； 可变性； 不可见性。

他还归纳了在次要问题上我们取得的进步： 高级语言； 分时系统； 统一开发环境。

次要问题我们就不展开了，相信大家都可以理解。 下面所有就都是摘录了，分别描述了4个主要问题。


复杂度。 规模上，软件实体可能比任何由人类创造的其他实体要复杂，因为没有任何两个软件部分是相同的（至少是在语句的级别）。如果有相同的情况，我们会把它们合并成供调用的子函数。在这个方面，软件系统与计算机、建筑或者汽车大不相同，后者往往存在着大量重复的部分。 数字计算机本身就比人类建造的大多数东西复杂。计算机拥有大量的状态，这使得构思、描述和测试都非常困难。软件系统的状态又比计算机系统状态多若干个数量级。 同样，软件实体的扩展也不仅仅是相同元素重复添加，而必须是不同元素实体的添加。大多数情况下，这些元素以非线性递增的方式交互，因此整个软件的复杂度以更大的非线性级数增长。 软件的复杂度是必要属性，不是次要因素。因此，抽掉复杂度的软件实体描述常常也去掉了一些本质属性。数学和物理学在过去三个世纪取得了巨大的进步，数学家和物理学家们建立模型以简化复杂的现象，从模型中抽取出各种特性，并通过试验来验证这些特性。这些方法之所以可行——是因为模型中忽略的复杂度不是被研究现象的必要属性。当复杂度是本质特性时，这些方法就行不通了。 上述软件特有的复杂度问题造成了很多经典的软件产品开发问题。由于复杂度，团队成员之间的沟通非常困难，导致了产品瑕疵、成本超支和进度延迟；由于复杂度，列举和理解所有可能的状态十分困难，影响了产品的可靠性；由于函数的复杂度，函数调用变得困难，导致程序难以使用；由于结构性复杂度，程序难以在不产生副作用的情况下用新函数扩充；由于结构性复杂度，造成很多安全机制状态上的不可见性。 复杂度不仅仅导致技术上的困难，还引发了很多管理上的问题。它使全面理解问题变得困难，从而妨碍了概念上的完整性；它使所有离散出口难以寻找和控制；它引起了大量学习和理解上的负担，使开发慢慢演变成了一场灾难。


一致性。

并不是只有软件工程师才面对复杂问题。物理学家甚至在非常“基础”的级别上，面对异常复杂的事物。不过，物理学家坚信必定存在着某种通用原理，或者在夸克中，或者在统一场论中。爱因斯坦曾不断地重申自然界一定存在着简化的解释，因为上帝不是专横武断或反复无常的。 软件工程师却无法从类似的信念中获得安慰，他必须控制的很多复杂度是随心所欲、毫无规则可言的，来自若干必须遵循的人为惯例和系统。它们随接口的不同而改变，随时间的推移而变化，而且，这些变化不是必需的，仅仅由于它们是不同的人——而非上帝——设计的结果。 某些情况下，因为是开发最新的软件，所以它必须遵循各种接口。另一些情况下，软件的开发目标就是兼容性。在上述的所有情况中，很多复杂性来自保持与其他接口的一致，对软件的任何再设计，都无法简化这些复杂特性。


可变性。

软件实体经常会遭受到持续的变更压力。当然，建筑、汽车、计算机也是如此。不过，工业制造的产品在出厂之后不会经常地发生修改，它们会被后续模型所取代，或者必要更改会被整合到具有相同基本设计的后续产品系列。汽车的更改十分罕见，计算机的现场调整时有发生。然而，它们和软件的现场修改比起来，都要少很多。 其中部分的原因是因为系统中的软件包含了很多功能，而功能是最容易感受变更压力的部分。另外的原因是因为软件可以很容易地进行修改——它是纯粹思维活动的产物，可以无限扩展。日常生活中，建筑有可能发生变化，但众所周知，建筑修改的成本很高，从而打消了那些想提出修改的人的念头。 所有成功的软件都会发生变更。现实工作中，经常发生两种情况。当人们发现软件很有用时，会在原有应用范围的边界，或者在超越边界的情况下使用软件。功能扩展的压力主要来自那些喜欢基本功能，又对软件提出了很多新用法的用户们。 其次，软件一定是在某种计算机硬件平台上开发，成功软件的生命期通常比当初的计算机硬件平台要长。即使不是更换计算机，则有可能是换新型号的磁盘、显示器或者打印机。软件必须与各种新生事物保持一致。 简言之，软件产品扎根于文化的母体中，如各种应用、用户、自然及社会规律、计算机硬件等等。后者持续不断地变化着，这些变化无情地强迫着软件随之变化。


不可见性。

软件是不可见的和无法可视化的。例如，几何抽象是强大的工具。建筑平面图能帮助建筑师和客户一起评估空间布局、进出的运输流量和各个角度的视觉效果。这样，矛盾变得突出，忽略的地方变得明显。同样，机械制图、化学分子模型尽管是抽象模型，但都起了相同的作用。总之，都可以通过几何抽象来捕获物理存在的几何特性。 软件的客观存在不具有空间的形体特征。因此，没有已有的表达方式，就像陆地海洋有地图、硅片有膜片图、计算机有电路图一样。当我们试图用图形来描述软件结构时，我们发现它不仅仅包含一个，而是很多相互关联、重叠在一起的图形。这些图形可能描绘控制流程、数据流、依赖关系、时间序列、名字空间的相互关系等等。它们通常不是有较少层次的扁平结构。实际上，在上述结构上建立概念控制的一种方法是强制将关联分割，直到可以层次化一个或多个图形2。 除去软件结构上的限制和简化方面的进展，软件仍然保持着无法可视化的固有特性，从而剥夺了一些具有强大功能的概念工具的构造思路。这种缺憾不仅限制了个人的设计过程，也严重地阻碍了相互之间的交流。

## 03
不是大牛，但从初中开始接触编程时间也挺长了，也来谈谈对编程的想法

不同的人对编程难的理解是不同的，因为编程本身的维度是不一样的，但最根本的，难在复杂性的控制，而不是一个个独立的概念. 普通的像office上写个vba,此时需要的只是永远不会变的业务逻辑，并且这种代码一般都是一个人写的1000行以内，因此你不需要软件工程的知识，时间长了也许会有编程很简单的错觉．这种编程最难的难在逻辑．

逻辑的难再上升一点便是算法，数据结构，这时候你会学到时空复杂度，学会用三种方法证明快排的时间复杂度，知道了现代计算机在面对非Ｐ类问题的无力，知道图灵机对于undecidable的问题的局限性，知道了用泵引理证明标准正则表达式永远也找不到匹配的括号，这时候你觉得很难，难在发现计算机其实干不了很多事．

接下来你或许回去刷各路oj,面对题目，第一步难在问题的抽象＼建模上，第二步难在抽象出中正确模型后算法的选择上．也许一个非常像贪心的题结果是网络流，也许一个非常像DP的题，结果是最短路，矩阵快速幂．．．．抽像出模型后，根据实际问题的各种条件选出最优方案，例如这种形式的dp 可以单调栈，斜率，平行四边形优化，选择在线or离线算法？稀疏图还是稠密图？这时候你会觉得很难，难在最基础的算法



接下来你会细分到具体的领域，此时的难就难在领域知识，这也是见仁见智．图形学各种立体角的积分也许对你很难，数学系转过来的小张也许就觉得公式比代码来得亲切．当然你也可以不管的，将系统看成一个黑盒，无脑调用现成的api,你不必关注神经网络是如何backpropagation的tensorflow,caffe等成熟的库已经把所有东西封装的很好了,你不必关注C++ RTTI的特性是如何实现的，现实生活中存在着大量这样的＂程序员＂，当发生问题时，梯度消失？爆炸？即使没有太难的专业知识只是业务逻辑，为啥我把循环展开速度会快那么多(gcc O2默认不进行循环展开优化)？为啥我只是把数组长度变一下速度立马变了？他们也可以试出很多经验规律，可以工作的很出色，但他们会觉得很难，这样的难，难在编程所在平台，领域专业本身的复杂度，如同上面循环展开等，是由于目前ＣＰＵ采用的分支预测策略以及pipeline被打断，因此也算作领域的知识



最后，你终于开始写real world的代码了，你会发现代码有10个G!用vs2017加载所有代码便是一个晚上，你这辈子都无法全部读完所有代码，此时你发现，控制代码复杂度非常难．当新增一个需求，坏味的代码要在密密麻麻的代码和文件中修改一两个参数，代码之间耦合非常大，Ａ功能调好Ｂ功能不能用，ＡＢ都调好Ｃ又不能用，等Ｃ再调好，少年，晚上３点了，不要再加班了．一群人同时编译一个函数，一个类，一个文件，你刚准备提交，别人又在这个文件里做了改动conflict了，你又只能花半小时把代码合回去，又要看别人的合代码防止冲突，合完刚想提交又有一个人提交，又conflict了．如果之前的东西偏计科，那这里便是偏软工的难度了．你会学着让代码分层，使用单例让其只有一个访问入口点，减少全局变量．体会到了don't repeat urself的用处，看到一长段if else的逻辑，会想到用策略模式让其变成一个个分散的类了，不再用全局变量了，识别清楚了哪些地方可能会有改动，日后业务可能会有扩展，提前调整架构．例如日后项目要增加支持中英双语了，别人还在忙着将string改成wstring,仿佛重新写一个系统，而你由于代码架构灵活只要将新加的语言翻译好即可．

这才明白所谓架构，不如接地气的说下是整理代码，就好像面对一个巨大的房子，里面各种凌乱的衣服，电器，家具，你要做的是把袜子分们别类的放到一堆，并且整个房子只有这个柜子能找到袜子，用完也只能放到这个柜子里，这样就不至于东一只袜子，西一只袜子，遥控器的按钮不能串，不能想打开电视机，空调也打开了;当一个柜子塞满了衣服，并且有很多不同的人来取这些衣服，不如分出一些小柜子，按取的人分门别类，如果有若干人自己的衣服太多，则分出来春装夏装秋装继续分小柜子;房子的某些位置识别出可能日后会搬进新家电，那一开始走线的时候就要在那儿装接线板，插座，架构这个词太高高在上了,整理才适合



接着你会发现ＯＯ的思想本来就有着非比寻常的复杂度，每一个instance都是带状态的，这一次调这个接口的状态和下一次可能是不一样的，它是不纯的．当遇到并发的情况时，这个缺点尤为明显．你也许会接触ＦＰ那套纯函数的想法来消除副作用，然后打开了一扇崭新的大门．



编程难在哪里，不同的人，时期都会有不同维度的回答，但在我看来，编程的难在于世界本来就是复杂的，而编程只是用逻辑去模拟整个世界，编程的难在于逻辑的难，世界的难



这时候你刚接触TMP的学弟对着动辙上百个编译错误的甚至把编译器搞挂的代码，说编程好难啊　　　　　　　　　　－－－－是啊，编程好难啊
## 04
最近项目逼紧，老同事有一个bug始终解决不了，拖了半个月了，老大就把我给派过去协助。

我们做的是用C语言生成硬件代码（更低层的verilog，verilog是一门硬件编程语言），懂这个的知道这个叫做HLS开发（高层次综合）。

HLS算得上是比较新的东西，因为传统上设计硬件，都是直接coding 硬件设计代码。几十年都是如此，直到最近几年HLS开始慢慢有了应用。

他那段代码并不是很复杂，总共30多行，我反复阅读了代码，逻辑功能没有问题，仿真也没有问题。纯C语言仿真可以实现想要的功能。

综合成底层的verilog代码的过程中也没有报错。

但是综合得到的verilog代码，跟C代码的功能却不一致。

也就是说工具并没有成功的从C语言转换到我们需要的verilog语言。

我们初步断定是coding style的问题，因为HLS对C语言的写法有要求，如果写的不好，要不综合得到的硬件性能不好面积太大，还有可能综合的不对。

因为肉眼看不出来，所以暴力的方法，就是重新写一个。换一种写法，说不定运气好能过。

所以我试了另外一种写法，用了一种高级的数据类型，代码只有10行。

综合结果也不对。

我把其中的部分代码一行一行删掉，最后只剩下4行，终于对了。

所以我判定另外6行有问题。

我对另外6行再次改写，把一些常变量换成固定数值，发现固定数值就没有问题。

看到了一点曙光。

于是我开始怀疑是一个常量的数据类型错了。

原代码里面常量采用了constant int的类型，当我将其改成ac_int<32,true>的时候，终于对了。

所以你看，我们搞了一个星期，到最后发现就是一个变量类型定义不对。

总代码数非常少，也就是十几行，修改的地方也就几个字符。

但是为了得到这个结果，我们试了十几种方法，换了各种各样的coding style。

编程难的地方的就是这里。写的时候很爽，觉得自己思路清晰，写完了，全是bug。

bug多了，就觉得没意思了。

现在的编程，说是高级语言，其实还是人在理解机器。

为什么Class复制之后只是指针复制了？别的变量复制之后整体都被复制了？

这些都是为了机器的方便，为了少点开销，对人只会造成混淆。

机器不具有容错能力，机器一遇到bug只会撒手，说白了还是我们的机器不行。

我们仍然处于编程历史的初级阶段。

世上难的事情有很多，编程绝不是最难的那一个梯队的，但也绝不简单。如果要类比，编程有点像做木工：入门不难，路边拿三五木棍，削平了摆个你好世界，便算是入了门，但倘若要做个梯子，便要把技巧打磨的娴熟了，不能出岔子，还得做的通用，出了小问题，别人也能修修补补，并不是说你把梯子拼起来，立起来便好了。要再进一步，那你感觉自己融会贯通了，知晓别人造梯子时候用啥东西，给别人造点顺手的工具，便是常说的造轮子了。

言归正题，编程有多难？

很多人在入门了没多久，拿着别人做好的工具，写了一些简单的功能之后，就觉得自己融会贯通了，有点管中窥豹的感觉。学的越多，越感到自己的渺小。感觉编程在现在的力扣君眼里，有这些难点：




1、良好的工业化编程能力
之所以把这一点放在第一，是因为很多学生刚毕业的时候，拿着写大作业的心态去写项目--只要跑得起来就好，或是拿着刷题的心态把出题人给定的case都解决就好去写逻辑。

但真的到工业开发中，写的后端代码要到线上跑，每一个漏洞都可能被攻击利用；前端代码面临破解、也面临着各种神奇操作带来的 corner case。相比算法编程，工业化开发更需要保证代码的稳定性，这件事情，可能真的需要实际经历后才能明白。初入行业的萌新往往会在上来的几次 review 中被满屏的 comments 击碎信心。

力扣君曾经遇到过一个刚毕业的实习生，写代码甚至需要依靠策划去给他排，这一块写这个，这一块写那个，如果让他自己写，写着写着都写到一个程序里，单个文件 3000 多行，然后结构混乱，有次甚至出了个循环调用的 bug，自己完全无法检查出来。没有好的代码梳理能力，会使自己的代码显得很杂乱。

2、对未知问题的分析、简化，优秀的逻辑能力
程序思维，往往出现在各种段子里，什么“看见苹果就买一个”。但程序思维确实对开发很重要。

瞎写半小时，调试一整天。很多时候，debug 是写代码过程中的常态。很多时候，你并不一定能通过报错信息获得错误的具体信息，甚至往往是别人的代码。这种时候，优秀的程序思维能够大幅缩短你定位到 bug 所花费的时间。但这个能力，只能在不断地工作中锻炼。

很多人写代码的时候，没有良好的逻辑思维，在后续往往会遇到各种不能理解的问题。在合作的时候不能理解别人的意图，自己写的时候没法架起完整的框架。各种各样的问题都会接踵而至，可以说，这是在开始自己写代码后最容易被搞崩溃的难点了。

我认识的很多优秀的程序员，都具备一种能力，当QA或者运营报了一两个 bug，能迅速反应出错误的点在哪，迅速定位问题，这是建立在熟悉代码和优秀的逻辑思维上。

3、良好的协作能力
不知道什么时候，程序员变成了 “低情商”、“差衣品” 的代名词。但如果你没有一个良好的心态调节能力，没有一个专业的态度，在合作的过程中往往会疯狂吃亏。包括 review 别人代码，与产品协商工期，与其他程序制定接口，都是妥协与商议，并不是完全内向的人能胜任的。

这些难点，大概是一个萌新成为一个合格的工业化程序员所面对的困难，再往后的，成为大佬有多难，就等诸位成为大佬后和我们分享了。

