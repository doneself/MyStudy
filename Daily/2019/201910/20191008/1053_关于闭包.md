## 关于闭包
https://cnodejs.org/topic/5d39c5259969a529571d73a8

就如同它的名字描述的一般，闭包表示的是一个封闭的内存空间。
每个函数被创建的时候，都有一个与之关联的闭包。
在了解闭包的使用场景之前，先看下面一个例子：

``` javascript
function f() {
  var i = 0;
  console.log(i);
}

f();
```

这段代码非常简单。我们知道一旦 f 执行完毕，
那么它本次执行的栈上的数据将会被释放，
所以每次调用结束后，栈上的 i 都会被及时的释放。

再来看另一个例子：

``` javascript
function f() {
  var i = 0;
  return function () { // f1
    console.log(i);
  }
}

var ff = f();
ff();
```

和第一个例子一样，这段代码同样会打印 0。
但是这似乎打破了我们第一个例子的总结，
按照第一个例子的说法，f 运行结束后，本次调用的栈上的 i 应该被释放掉了。
但是我们随后调用返回的匿名函数，发现并没有报错，这就归功于闭包。

每个函数被创建的时候，都会有一个与之关联的闭包被同时创建。
在新创建的函数内部，如果引用了外部作用域中的变量，那么这些变量都会被添加到该函数的闭包中。

注意上面代码的注释，为了方便描述，
我们将匿名函数取名为 f1。
当 f 被调用的时候，f1 被创建，同时与之关联的闭包也被创建。
由于 f1 内部引用了位于其作用域之外的、f 作用域中的变量 i，
因此 f 作用域中的 i 被拷贝到了 f1 的闭包中。
这就解释了，为什么 f 执行完成之后，调用 f1 依然可以打印 0。

现在来看一下第三个例子：

``` javascript
function f() {
  var i = 0;
  function f1() { 
    console.log(i);
  }
  i = 1;
  return f1;
}

var ff = f();
ff();
```

我们会发现打印 1。
好像又与第二个例子的结论有些冲突，
f 中的 i 不是被拷贝到了 f1 的闭包中吗？
为什么不是打印 0 而是打印 1 呢？

这是因为，我们还没有介绍发生拷贝的时机。
如果新创建的函数，引用了外部作用域的变量，并且该变量为活动的，
那么并不急于将该变量的内容拷贝到闭包中，
而是将该变量所指向的内存单元的地址保存于闭包中。
比如我们这里，
只是先将 i 所绑定到的内存地址保存于闭包中，
等到 i 为非活动状态时，才会进行拷贝。
也就是这里，当 f 即将运行结束时，
i 的将变为非活动状态，那么需要将其内容拷贝到引用它的闭包中，也就是这里的 f1 的闭包中。
一旦内容被拷贝到闭包中，除了与之关联的函数对象之外，再也没有其他方式可以访问到其中的内容。

顺便介绍一下，那么闭包中占用的内存何时才会被释放呢？
答案就是当与它关联的函数对象被释放的时候。比如我们接着上面的例子运行：

``` javascript
var ff = null
```

我们将引用 f1 的变量 ff 赋值为 null，
这样就没有任何变量引用 f1 了，
所以 f1 成为了垃圾，会在未来的某个时间点(具体要看 GC 的实现以及运行情况)，由垃圾回收器进行所占内存回收。


上面的例子，其实就是下面的例子的简化版：

``` javascript
function f() {
  var a = [];
  for(var i = 0; i < 2; i++) {
    var ff = function () {
      console.log(i)
    };
    a.push(ff);
  }
  return a;
}

const [f1, f2] = f();
f1();
f2();
```

这里新创建的两个函数都会打印 2，
想必这个例子大家都很熟悉了，就不再赘述了。
只是有一个问题需要注意，
既然上面提到了说，
新创建的函数引用的外部作用域上的变量内容、
最终都会拷贝到该函数的闭包中，
那么上面的例子中，i 是不是被拷贝了两次？

再来看一个例子：

``` javascript
function f() {
  var a = [];
  for(var i = 0; i < 2; i++) {
    var ff = function () {
      console.log(i)
    };
    a.push(ff);
  }
  a.push(function () {
    i++;
  });
  return a;
}

const [f1, f2, f3] = f();
f1();
f3();
f2();
```

这个例子会打印什么？
答案是 2 和 3。
这是因为闭包的另一个机制，
同一个变量被引用它的多个闭包所共享。
我们在 for 循环内部创建了两个函数，
在循环外部创建了一个函数，
这三个函数的都引用了 f 中的 i，
因而 i 被这三个函数的闭包所共享，
也就是说在 i 离开自己所属的作用域时(f 退出前)， 将只会发生一次拷贝，
并将新创建的三个函数的闭包中的 i 的对应的指针设定为那一份拷贝的内存地址即可。
对于这一个共享的拷贝地址，除了这三个闭包之外，没有其他方式可以访问到它。

必须再次强调的是，
被引用的变量拷贝到闭包中的时机发生在、
被引用的变量离开自己所属的作用域时，即状态为非活动时。
考虑下面的例子：

``` javascript
function f() {
  const a = [];
  for(let i = 0; i < 2; i++) {
    var ff = function () {
      console.log(i)
    };
    a.push(ff);
  }
  return a;
}

const [f1, f2] = f();
f1();
f2();
```

我们知道 ES6 中引入了 let 关键字，
由它声明的变量所属块级作用域。
在上面的例子中，
我们在 for 循环体的初始化部分使用了 let，
这样一来 i 的作用域被设定为了该循环的块级作用域内。
不过另一个细节是，循环体中的 i ，也就是 ff 中引用的 i，
在每次迭代中都会进行重新绑定，
换句话说循环体中的 i 的作用域是每一次的迭代。
因此在循环体中，当每次迭代的 i 离开作用域时，
它的状态变为非活动的，因此它的内容被拷贝到引用它的闭包中。

闭包常常会和 IIFE 一起使用，比如：

``` javascript
var a = [];
for(var i = 0; i < 2; i++) {
  a.push((function (i) { // f1, i1
    return function () { // f2
      console.log(i) // i2
    }
  })(i)); // i3
};

const [f1, f2] = a;
f1();
f2();
```
