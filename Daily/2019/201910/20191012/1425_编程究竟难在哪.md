# 编程究竟难在哪

## 0001
编程的难分为两类，一种是工程上的难，一种是算法上的难。

我先回答一下工程上的难：

我们做一个比较, 就是开发一个大型软件, 和设计并建造一栋摩天大楼, 究竟哪个更难, 为什么?

实际上这个比较一旦抛出, 软件开发的"难"就立马显现出来了。

摩天大楼一旦盖起，将不再，也不可能“更新版本”，更不可能在建筑结构上进行“重构”，比如一个一百层的摩天大楼，不可能说过两个月发现地方不够住，然后再加五层，又过了两个月发现某个房间的设计满足不了人们日益增长的需求，将整个房间扩大两倍，究其原因，就是因为“建筑”这个东西太不灵活了，你如果想“重构”这个摩天大楼，几乎只有一个办法：炸毁，推倒重来。

而对于软件来讲，它本身的一个灵活性，导致了它可能在不破坏原有的大部分功能的前提下进行一定的功能性改造，在改造的过程中，原有的一些功能模块的更改，可能导致之前的一些文件或环境， 或应用程序在这个新的版本下出现不兼容的现象，所以它要保证旧的东西在新的东西下能成功运行。

一个东西越是牵扯的东西多，越和环境耦合，和“用户”耦合越深，和“自身”耦合，和“历史”耦合越深，它的“更新”就越难，而“重构”是多次更新之后的“必然结果”。

这就是为什么摩天大楼几乎无法进行功能性更新，因为建筑这个东西本来就是一个“超级耦合体”，你改变墙壁的厚度，会减轻它的重量，但于此同时因为墙厚度降低，它本身的抗压刚度和抗扭刚度也发生了降低，所以后果可能还需要重新计算，墙里面的电线会不会因为墙的厚度改变而需要重新布线？而且不仅如此，墙的厚度还会改变房间的大小，这是它和其自身的高度耦合。

它和用户的耦合性也很深，因为这个房间的一些地方有可能早已住了人，原有的位置放置了很多用户的东西，比如一些很重的家具等，你对墙重新施工，就意味着你要强迫用户更改它们原有的使用习惯，甚至可能让用户原有的一些家具无法在新的版本中放进去，这是用户的耦合性。那么类比软件，比如我们都知道的excel，这个软件开发了二十多年，你在2003版的excel里编辑的，十几年历史的excel文件，你觉得可以在2018版的excel中打开吗？这听起来很不容易，但是微软做到了，这就是为什么说现在除了微软几乎没有公司有能力开发出这样的软件，原因之一就是它变态的兼容性，长达十几年的时间跨度，版本跨度，保证文件的兼容性，这本就很了不起。

所以向前兼容是软件开发的主要难点之一。

有时候不仅是某个功能模块的更新，随着一个”服务型“的应用不断发展，它要提供服务的用户量就会不断提升，一个典型的例子是淘宝，学过数据结构的我们知道，这世界上很多东西的复杂性并不是线性增长的，简单的例子就是排序，最优的时间复杂度也是nlog（n），理想世界如此，现实世界怎么可能更简单！

十年前php可以撑起淘宝的流量，而今天呢？php的性能问题恐怕让其无法再承担淘宝的亿级流量，所以只能用java重写，而这就是重构，重构其实就可以认为是推倒重来，代价很大，需要更换技术栈，但必要时不得不做。

有人说服务一万人用一台服务器，那么服务一亿人用一万台服务器就解决了，哪来那么多事，而这也正是我刚才说的，陷入了”线性增长思维陷阱“。

一万人的时候，可能有时候可以让系统停掉，进行一到两小时的服务器维护，这一万人也不会因为你停了服务器就有多大的损失，那一亿人呢？你的服务器集群敢断电吗？敢让网站挂掉进行网站维护吗？

所以既然要让网站每时每刻不断运行，就首先要做到持续集成，持续部署，对应用进行完善的版本控制，为了降低系统bug风险要进行完善的发布前测试，而测试又分单元测试和集成测试，缺一不可。为了防止某个地区的服务器因为突发事故，比如地震，火灾，大面积停电等事故发生宕机甚至损毁，我们需要进行服务器的异地容灾，那么另一个地区马上就能无缝根据原有服务器的中断镜像进行服务重建，做到服务端这边“山崩海啸”，用户端那边还能一如既往的从容淡定，感觉什么事都没发生一样。

所以，扯了这么多，我用一句话总结编程的”工程性难点”就是，你如何在这错综复杂的耦合中，在复杂性不断增加的过程中，如何让软件有序，规范地”进化“，而不是让其肆意疯长，最后成为一坨无人能懂，无人敢碰的”屎山“。

算法上的难明天再来答。

算法的难主要集中在两点, 一种是算法的构思和提出, 一种是提出算法之后, 用code实现出来。

个人认为算法的构思和提出最为困难，因为这部分经常要求我们将我们眼中“显然”的东西，转换成计算机语言。

比如我们现在要实现一个算法，这个算法能够识别一张图片，判断图片中是否有人脸，对于人类来讲，这是不经思索的，一眼就能看出来的，但是问题是，你自己也不知道你自己是怎么看出来的，这个判断过程，其实我们的大脑内部发生了很复杂的化学反应，但是我们却说不清，我们到底是怎么判断的，还比如判断人脸的情绪等等。

但有人说，这说明计算机比人笨，事实上完全不是这样，计算机从来就不比人笨，事实上比起人类能做到的事计算机做不到，计算机能做到人类做不到的事反而更多。

计算机的特点就是容错率低，但是可预测性强，确定的代码和输入就能得到确定的结果和输出。

人类的特点是容错率高，但是可预测性差，对一个东西的执行结果经常受情绪，身体状况，心态等的影响，结果常常是不确定的。

所以其实，一个系统的”容错率“和”可预测性”是个永远不可调和的矛盾，一个编程语言如果具有一定的容错率，看起来好像编程更为容易，实际上反而是灾难，bug更难发现，问题更难复现，一个运行正常的系统很有可能有一天脑子一抽输出一个错误结果, 这就是为什么几乎所有语言都有异常抛出机制, 就是为了降低容错率。

所以我们要注意一点就是，编程困难，并不是因为计算机不够先进，不够智能，而是我们为了“可预测性”，心甘情愿地接受了这种极低的“容错率”，这直接导致你写程序，少打一个分号，编译错误，打错一个变量名，编译错误，数组越界，编译错误。

容错性这么低，你还指望它能接受人类这种模糊的自然语言？当然不可能了，所以它一定有自己的，语义清晰的语言。

一个语言一旦语义清晰了，语言灰度底了，它一定是逻辑性很强的，或者说，我们其实是用逻辑写代码，而不是用“感觉”或是“情感”写代码，这和我们人类理解世界的方式本来就是有区别的。

人类虽然有逻辑思维的能力，但是逻辑思维从来就不是人脑的强项，人脑的强项其实是整体感知，和一些“系统预设”的功能，比如你眼睛睁开了，投入你视网膜的光就会自动的转换成图像信息被你感知，这个过程你调用了任何逻辑思维了吗？你几乎什么感觉都没有就完成了一个极其复杂的过程。

所以我们的大脑绝大多数复杂的进程，或者说运行过程，都不能被我们逻辑性地去感知，比如你听到一首歌，这首歌给你一种很舒缓的感觉，你说你听着这首歌仿佛进入了一片天灵之地，但是这个过程，请问你进行了任何逻辑思维没有？

你就是感觉了一下而已，但是我们想让机器去做这样的“感知”，因为计算机体系的极低容错性，我们必须用我们的逻辑思维搞明白，这首歌，究竟是因为什么，它有什么样的特质，才导致了它给你这样的舒缓感觉，这样你才可能把这个过程转换成计算机语言输入到计算机中，让计算机去判断这首歌是“舒缓的“还是”狂野的“。

所以我总结一下编程在算法上的难，就是：

人类这种容错率高，可预测性差的生命，非要逼着自己去和一个容错率低的，可预测性强的这样一种”硅基生命“交流，不得不逼着自己用逻辑性很强的语言去和他交流, 在这个过程中我们不得不打破我们原有的感觉和感知, 对其进行逻辑解构, 这样才能让跨物种交流得以实现.

看到这里，你一明白了，要想让两种不同的生物更好的交流，要不就是让人类变得更像计算机，要不就是让计算机变得更像人。

你想一下siri，cortana这种语音助手，它是不是具有一定的不可预测性？你和它说一句话，你知道他要回复你什么吗？不知道，但也正因为如此，我们让计算机变得更像人类，从而让人类这一端，可以更轻松地和计算机交流，这其实就是人工智能。

一个AI的算法模型种，往往要引入大量的参数，然后不断地输入样本，根据预测值和真值是否匹配而动态地改进这些参数，这样一个系统，容错率是低了，可预测性呢？确定的AI算法模型能得到确定的预测结果吗？

所以与此同时，你也要注意。

容错率低的，重要的事不要交给siri去做，因为它和人一样，不可预测。


## 0002
编程一点都不难；它只是和你十几年来在学校受的教育格格不入而已。



自小你受到的教育，总是：

1、记忆和理解一个个的知识点

2、给你一个未完成的拼图，让你把自己记忆的、某几个合适的知识点以正确的姿势放进去（超过三个就是难题，超过五个就是压轴题！）

3、好了，满分



换句话说，你从未学过创造；你只是被训练的极为擅长“填补拼图中缺失的一角”而已。

看我的这个回答：代码是如何控制硬件的？



嗯，显示所有答案，你会发现另一个怼我的答案排在第一。

他说，“高票答案没有真正回答问题”，而许多许多人表示同意——而且非常反感那些装X的答案，以至于要狠狠踩上一脚。



搞笑的是，他的答案也被很多人认为“没有真正回答问题”。



终于，我知道这些人缺失的是哪一环了。于是不得不添加这么一段回复：

解释下这个抽象的0/1是如何出现/消失于电路中的。

事实上，电路中压根就没有0和1。

就好像你手机充电器的指示灯一样，当它接通电源时，指示灯亮；拔下来扔桌子上，指示灯灭。

很多人胶柱鼓瑟，非要在里面找“充电器是怎么知道自己有没有插到电源上的”。

但实际上，我们每个人都知道，指示灯就是盏灯而已。接到电上，它不亮也得亮；拔下电源，它想亮也亮不了。

同样的，电路中压根不存在什么0和1。我们给它插电，然后合上开关，某段电路便得到了供电——然后我们给这个状态起个名字叫高电平。

它和充电器一样，是一件死物。它压根不知道任何东西。

但我们需要知道它的状态。所以我们不得不在电路中接入指示灯（或电压表），然后根据指示灯的明灭，我们才知道电路是哪个状态。

进一步的，聪明的人类把“指示灯”做成0或1的形状，就把电路状态以一目了然的形式表现出来。
甚至于，我们还可以把它转换为屏幕上的图形/字符、音箱中的声音，从而间接的看见/听到电信号。

再说一遍：电路中不存在0和1。它们只是按基本物理规律运行而已。为了方便我们理解，我们才想办法做了一些“高级指示灯”，从而使自己能以0/1甚至汉字/图像的方式直观理解电路状态。

太多人严重缺乏这种最基础的动手能力，不知道人才是本体，这才总是傻乎乎的想找到“电子器件究竟在哪个点获得了智能”。


可笑吧？这么个幼儿园级的简单问题，得如此长篇大论才能说清楚——显然，他们甚至压根就没有把一个幼儿园级的问题表达清楚的能力。因为能说清楚他们自己就会完成思考了（这也是那个认为“高票没有解决问题”所以自己走低彻底解决了问题、然而还是有人在他的评论区疑惑“0/1怎么对应到高低电平上”的原因）。



幼儿园不解决；现在，想要教会他们，你就必须彻彻底底的掰开、揉碎，像喂两个月的婴儿那样一点点给他们喂！

实质上，这已经等于教不会了。

当然，这个问题实在太简单、太初级；大多数人在他们上幼儿园之前就已经解决掉了。



所以，读到上面那段文字，你可能无法感同身受。



那么，这段呢？

我们高中数学为什么不重视算法？高中学的数列，三角函数，求导，圆锥曲线相关问题的解法和算法有什么关系？

编程不难。但它要你创造。



过去你已经习惯了的、出题人准备好一切、只留下一两个缺口让你补充拼图的“思考”方式，在这个领域渣都不是。



听着，你不需要学习什么“语言”。C/C++、Java、Go、PHP、Python……统统用不着。



你只需要知道，程序语言有顺序分支循环三种控制结构、与或非三种逻辑——剩下的，统统靠你自己。



不。你就是再读一千本书，也甭想靠这个把“编程的技能”直接灌进你脑子里。没那好事。



相反，你必须自力更生，你必须靠着“鄙陋”的顺序分支循环和与或非以及中小学水平的数学运算支持，解决手头的一切问题。



你学的是编程，不是编程语言。

脱掉C的底裤，并不能帮你写出哪怕一个简单的鼠标驱动程序。

混知乎或其他网络论坛，总有人忍不住骂“你们码农怎么什么话题都想插一嘴？”



很遗憾。但程序员的工作，恰恰正是“理解各行各业的工作，然后把它教给电脑”。



没错。

学编程，学的甚至不是计算机本身；相反，它要求你从声学到视觉暂留、从结构力学到滤波解调……随便哪行哪业，你都要能够快速抓住重点、然后把它说的清清楚楚明明白白，这才可能把它教给计算机、让CPU代替人工作。



如果连“手电筒的原理”你都理解不了、如果连“遥控小车”这样简单的发明你都做不到“信手拈来”……那么，他人从液体分层原理借来的冒泡算法、从猜测的人脑工作原理偷来的神经网络，你又怎么可能理解？

它要求的，是“从三百五百甚至成千上万个知识点中挑选出最合适的那几个、然后用它们解决你所面对的问题”！



编程真的不难；但你从未受过解决问题的训练。

而编程，恰恰就是最最纯粹的、以精确无歧义的方式表达问题解决方案的一种工作。



不。

你甚至不知道“学习编程”就是学习“如何用电脑解决问题”，反倒学编程语言本身去了……



这种学法，怎么可能不难？
## 0003
编程的本质，就是在事先约定的限制条件下，进行有逻辑无约束的创造活动，是目前人类所能进行的，最接近于神的造物的活动。简单说就是符合逻辑的创造。

当然，我们只是程序员，不是神，那区别到底在哪呢？就在于这个"限制条件"。

这个限制条件，可能是程序员所能操纵的硬件和实体资源，可能是其他科学所能达到的物理极限，也可能是理论上可能但实际上无法在可接受资源消耗内完成的工作量。一句话，这个限制就是"逻辑可能性"。

比如，你想要编程来煮咖啡。

现在的资源是，一台台式机，一台老式咖啡机。在这个场景下，这个任务是不可能完成的，因为你没有办法从物理上让计算机去操作咖啡机——这就是逻辑上不可能。

那么现在有了一台可编程咖啡机，就是说可以通过一些神奇的电路和开关什么的，向咖啡机发送指令。现在这台咖啡机可以从电脑上编程控制了。那么我想要一台每天定时煮咖啡的咖啡机，可以做到吗？——可以！因为电脑可以做到定时操作，而电脑又可以操作咖啡机，所以逻辑上没毛病！

现在又来了新的需求，我要远程煮咖啡，可以做到吗？那么，直观的逻辑看来，需要哪些物理条件？对，需要网络，并且远程能够连接到控制咖啡机的电脑。逻辑上没问题的需求，接下来程序员的工作就是将这个逻辑用代码的方式来实现。

所以，只要逻辑上客观条件容许，程序员和上帝的创造力是一个级别的。

那编程到底难在哪里？难在大多数人没有完善的逻辑素养。举个例子，以前曾经和某些知友讨论当前味觉为什么没法模拟的时候，有一位小朋友说这其实很简单的，发送端识别气味后，通过网络将信号发到接收端，接收端模拟出来这个气味就可以了。说得好像很简单而且看上去没毛病对吧？

那他错在哪里？他其实真没错。以后如果真的实现了味觉传输，我敢跟你赌五毛钱就是这样实现的。但是现在看来他说的是屁话，因为他觉得理所当然的两步"识别"和"模拟"，根本就是当前无法实现的，轻描淡写一笔带过简直是在嘲讽全人类的科技水平——可能神级文明才有这个资格吧。

逻辑能力不强的人，根本就注意不到他们自己思维中比筛子孔还多的漏洞。即使是经验丰富的程序员，在对业务理解不够或者思考欠周到的时候，也会由于逻辑不周全而导致bug。这就是编程难的地方。
